/*
Copyright 2024 Suredesigns Corp.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

import { AlierView } from "/alier_sys/AlierView.js";
import { ViewLogic } from "/alier_sys/ViewLogic.js";
import { ObservableArray } from "/alier_sys/ObservableArray.js";

/**
 * @class
 * 
 * A class for storing list items.
 */
class ListViewContainer extends ViewLogic {
    constructor() {
        super();
        this.loadContainer({ text: "<alier-container></alier-container>" });
        this.relateElements(this.collectElements(this.container));
    }

    /**
     * Sorts list elements with the given comparator.
     * 
     * @param {((object, object) => (-1 | 0 | 1))?} compare 
     * A comparator function comparing the given two objects.
     * Those objects are the value maps generated by using
     * `curateValues()` function of ViewLogic attached to each
     * of list item views.
     * 
     * If the comparator is not specified, the default comparator is
     * used instead.
     * The default comparator compares the all properties of the two
     * objects in the defined order.
     * 
     * @returns an index map. This is actually an array of plain objects
     * with two properties `from` and `to`.
     * Both properties are `number` and the `from` indicates where the
     * corresponding item is moved from and the `to` indicates where the
     * corresponding item is moved to.
     * 
     * @throws {TypeError}
     * when `compare` is neither `undefined` nor a function.
     */
    sort(compare) {
        //  requires
        //  requires - type check
        if (compare !== undefined && typeof compare !== "function") {
            throw new TypeError(`${compare} is not a function`);
        }

        /** @type {ViewLogic[]?} */
        const items = this.items;
        /** @type { ({ from: number, to: number })[] } */
        const index_map = [];
        if (items == null) {
            return index_map;
        }

        //  init - set comparator function
        const compare_= (compare == null) ?
            //  set default comparator function
            ([, x], [, y]) => {
                for (const k in x) {
                    const xk = x[k];
                    const yk = y[k];
                    const result = (xk !== yk) * ((xk > yk) - (xk < yk));
                    if (result !== 0) {
                        return result;
                    }
                }
                return 0;
            } :
            //  wrap the given comparator
            ([, x], [, y]) => compare(x, y)
        ;

        //  do - init variables used for sorting
        /** @type {ViewLogic[]} */
        const sorted_items  = new Array(items.length);
        /** @type {([number, object][])} */
        const indexed_items = items.map((v, i) => [i, v.curateValues()]);

        //  do - sort
        for (const [to, [from, ]] of indexed_items.sort(compare_).entries()) {
            if (from !== to) {
                index_map.push({ from, to });
            }
            sorted_items[to] = items[from];
        }

        this.relateViewLogics({ items: sorted_items });

        this.container.append(...(function* () {
            for (const sorted_item of sorted_items) {
                yield sorted_item.container;
            }
        })());

        return index_map;
    }

    /**
     * Sorts list items by the given key.
     * 
     * @param {string} key 
     * A key string used for sorting.
     * 
     * @param {boolean} ascending 
     * A flag represents whether or not sort is done in the ascending
     * order.
     * If this is `true`, sort is done in the ascending order,
     * otherwise, sort is done in the descending order.
     * 
     * @returns an index map. This is actually an array of plain objects
     * with two properties `from` and `to`.
     * Both properties are `number` and the `from` indicates where the
     * corresponding item is moved from and the `to` indicates where the
     * corresponding item is moved to.
     */
    sortByKey(key, ascending = true) {
        //  requires
        //  requires - type check
        const key_ = key;
        if (typeof key_ !== "string") {
            throw new TypeError(`${key_} is not a string`);
        } else if (typeof ascending !== "boolean") {
            throw new TypeError(`${ascending} is not a boolean`);
        }

        /** @type {ViewLogic[]?} */
        const items = this.items;
        /** @type { ({ from: number, to: number })[] } */
        const index_map = [];
        if (items == null) {
            return index_map;
        }

        //  init - set comparator function
        const order   = Number(ascending) * 2 - 1;
        const compare = ([, x], [, y]) => (order * ((x > y) - (x < y)));

        //  do - init variables used for sorting
        const sorted_items  = new Array(items.length);
        const indexed_items = items.map((v, i) => [i, v.curateValues()[key_]]);

        //  do - sort
        for (const [to, [from, ]] of indexed_items.sort(compare).entries()) {
            if (from !== to) {
                index_map.push({ from, to });
            }
            sorted_items[to] = items[from];
        }

        this.relateViewLogics({ items: sorted_items });

        this.container.append(...(function* () {
            for (const sorted_item of sorted_items) {
                yield sorted_item.container;
            }
        })());

        return index_map;
    }

    splice(startIndex, deleteCount, ...insertedItems) {
        const length = (this.items != null) ? this.items.length : 0;
        let start_index = startIndex;
        start_index = (
            typeof start_index === "symbol" ||
            typeof start_index?.toString !== "function"
        ) ?
            0 :
            Math.trunc(Number(start_index) || 0)
        ;
        if (-start_index > length) {
            start_index = 0;
        } else if (start_index > length) {
            start_index = length;
        } else if (start_index < 0) {
            start_index += length;
        }
        let delete_count   = deleteCount;
        delete_count = (
            typeof delete_count === "symbol" ||
            typeof delete_count?.toString !== "function"
        ) ?
            0 :
            Math.trunc(Number(delete_count) || 0)
        ;
        if (delete_count < 0) {
            delete_count = 0;
        } else if (delete_count >= length - start_index) {
            delete_count = length - start_index;
        }
        const inserted_items = insertedItems;

        /** @type {ViewLogic[]} */
        const items = this.items != null ? [...this.items] : [];

        const deleted_items = items.splice(start_index, delete_count, ...inserted_items);

        for (const deleted_item of deleted_items) {
            deleted_item.styles.remove();
            deleted_item.container.remove();
        }

        if (start_index + delete_count >= length) {
            this.container.append(...(function* () {
                for (const inserted_item of inserted_items) {
                    yield inserted_item.container;
                }
            })());
        } else if (start_index <= 0) {
            this.container.prepend(...(function* () {
                for (const inserted_item of inserted_items) {
                    yield inserted_item.container;
                }
            })());
        } else {
            /** @type {Element} */
            const sibling = items[start_index - 1].container;
            sibling.after(...(function* () {
                for (const inserted_item of inserted_items) {
                    yield inserted_item.container;
                }
            })());
        }

        this.relateViewLogics({ items: items });

        return deleted_items;
    }
}

/**
 * @class
 * 
 * A `AlierView` representing a list of monomorphic items.
 * 
 * Due to duality of AlierView and ViewLogic,
 * ListView also has ViewLogic as its counter-part.
 * However unlike plain AlierViews, ListView's dual is provided by itself but not the user.
 * The user can provide ListItemView's ViewLogic instead.
 */
class ListView extends AlierView {
    /**
     * number of contents
     */
    get length() {
        /**
         * @type {ViewLogic[]?}
         */
        const items = this.container?.items;
        return items != null ? items.length : 0;
    }

    get(index) {
        const length = this.length;
        if (length <= 0) { return undefined; }

        /**
         * @type {ViewLogic[]?}
         */
        const items = this.container?.items;
        if (items == null) { return undefined; }

        let index_ = index;

        index_ = (
            typeof index_ === "symbol" ||
            typeof index_?.toString !== "function"
        ) ?
            0 :
            Math.trunc(Number(index_) || 0)
        ;

        return items[index_ < 0 ? length + index_ : index_];
    }

    *slice(startIndex, endIndex) {
        const length    = this.length;
        if (length <= 0) { return; }

        /**
         * @type {ViewLogic[]?}
         */
        const items = this.container?.items;
        if (items == null) { return; }

        let start_index = startIndex;
        let end_index   = endIndex;

        start_index = (
            typeof start_index === "symbol" ||
            typeof start_index?.toString !== "function"
        ) ?
            0 :
            Math.trunc(Number(start_index) || 0)
        ;
        if (-start_index > length) {
            start_index = 0;
        } else if (start_index > length) {
            start_index = length;
        } else if (start_index < 0) {
            start_index += length;
        }

        end_index   = (
            typeof end_index === "symbol" ||
            typeof end_index?.toString !== "function"
        ) ?
            0 :
            Math.trunc(Number(end_index) || 0)
        ;
        if (-end_index > length) {
            end_index = 0;
        } else if (end_index > length) {
            end_index = length;
        } else if (end_index < 0) {
            end_index += length;
        }

        for (let i = start_index; i < end_index; i++) {
            yield items[i];
        }
    }

    /**
     * Gets an iterator of the target `ListView`'s contents.
     * 
     * @returns an iterator of the `ListView`'s contents.
     */
    values() {
        /** @type { ViewLogic[] } */
        const items = this.container?.items ?? [];
        return items.values();
    }

    /**
     * Gets an iterator of indices of the target `ListView`'s contents.
     * 
     * @returns an iterator of indices of the `ListView`'s contents.
     */
    keys() {
        /** @type { ViewLogic[] } */
        const items = this.container?.items ?? [];
        return items.keys();
    }

    /**
     * Gets an iterator of the target `ListView`'s contents with their indices.
     * 
     * @returns an iterator of indices of the `ListView`'s contents with their indices.
     */
    entries() {
        /** @type { ViewLogic[] } */
        const items = this.container?.items ?? [];
        return items.entries();
    }

    /**
     * Gets an iterator of the target `ListView`'s contents.
     * 
     * @returns an iterator of the `ListView`'s contents.
     */
    [Symbol.iterator]() {
        return this.values();
    }

    /**
     * Attached constructor of list items' container.
     */
    get template() {
        return this.#template ?? null;
    }

    /**
     * Attaches the template of ViewLogic instances.
     * 
     * @param {ViewLogic} archetype
     * Archetype of list items
     * 
     * @throws {TypeError}
     * - when `archetype` is not an instance of `ViewLogic`
     * 
     * @see
     * - {@link ListView.prototype.detach}
     */
    attach(archetype) {
        //  requires
        //  requires - check argument type
        if (!(archetype instanceof ViewLogic)) {
            throw new TypeError(`${archetype} is not an instance of ${ViewLogic.name}`);
        } else if (archetype.constructor === this.#template) {
            return [];
        }

        //  init - attach ListViewContainer if not attached yet
        if (this.container == null) {
            super.attach(new ListViewContainer);
        }

        const detached = this.detach();

        this.#template = archetype.constructor;

        return detached;
    }

    /**
     * Detaches template and its instances. 
     * 
     * @see
     * - {@link ListView.prototype.attach}
     */
    detach() {
        if (this.#template == null) {
            return [];
        }
        const items = this.container?.items;
        if (items == null || items.length <= 0) {
            this.#template = null;
            return [];
        }

        const detached = this.splice(0, items.length, 0);

        this.#template = null;
        return detached;
    }

    /**
     * Sorts list elements with the given comparator.
     * 
     * @param {((object, object) => (-1 | 0 | 1))?} compare 
     * A comparator function comparing the given two objects.
     * Those objects are the value maps generated by using
     * `curateValues()` function of ViewLogic attached to each of list item views.
     * 
     * If the comparator is not specified, the default comparator is used instead.
     * The default comparator compares the all properties of the two objects in the defined order.
     */
    sort(compare) {
        /**
         * @type {ListViewContainer?}
         */
        const container = this.container;
        if (container == null) {
            return this;
        }

        const index_map = container.sort(compare);
        this.#onSorted(this, index_map);

        return this;
    }

    /**
     * Sorts list items by the given key.
     * 
     * @param {string} key 
     * A key string used for sorting.
     * 
     * @param {boolean} ascending 
     * A flag represents whether or not sort is done in the ascending order.
     * If this is `true`, sort is done in the ascending order, otherwise, sort is done in the descending order.
     */
    sortByKey(key, ascending = true) {
        /**
         * @type {ListViewContainer?}
         */
        const container = this.container;
        if (container == null) {
            return this;
        }

        const index_map = container.sortByKey(key, ascending);
        this.#onSorted(this, index_map);

        return this;
    }

    /**
     * Deletes and inserts list items.
     * 
     * @param {number} startIndex 
     * An integer representing the position of the first item to be deleted or the previous sibling of inserted items.
     * 
     * If a negative value is given, it is interpreted as a reverse index running from the last item to the first.
     * 
     * If the given index exceeds the list length, it is replaced with the index of one of the nearest list ends,
     * 0 if negative, the list length otherwise.
     * 
     * If non-integer value is given, it is rounded off to 0.
     * 
     * @param {number} deleteCount 
     * A number of items to be deleted.
     * 
     * If `startIndex + deleteCount` exceeds the list length, `deleteCount` is replaced with `(list length) - startIndex`.
     * 
     * If a negative value is given, it is replaced with 0.
     * 
     * If non-integer value is given, it is rounded off to 0.
     * 
     * @param {number} insertCount 
     * A number of items to be added.
     * 
     * If a negative value is given, it is replaced with 0.
     * 
     * If non-integer value is given, it is rounded off to 0.
     * 
     * @returns {ViewLogic[]}
     * An array of ViewLogics of removed items.
     */
    splice(startIndex, deleteCount, insertCount = 0) {
        /**
         * @type {ListViewContainer?}
         */
        const container = this.container;
        //  requires - returns if container is not attached.
        if (container == null || this.#template == null) {
            return [];
        }

        //  init - get item list
        const items = container.items ?? [];
        const length = items.length;

        //  init - convert each of the given arguments to its appropriate value.
        //  init - convert startIndex
        let start_index = startIndex;
        start_index = (
            typeof start_index === "symbol" ||
            typeof start_index?.toString !== "function"
        ) ?
            0 :
            Math.trunc(Number(start_index) || 0)
        ;
        if (start_index <= -length) {
            start_index = 0;
        } else if (start_index > length) {
            start_index = length;
        } else if (start_index < 0) {
            start_index += length;
        }

        //  init - convert deleteCount 
        let delete_count = deleteCount;
        delete_count = (
            typeof delete_count === "symbol" ||
            typeof delete_count?.toString !== "function"
        ) ?
            0 :
            Math.trunc(Number(delete_count) || 0)
        ;
        if (delete_count < 0) {
            delete_count = 0;
        } else if (delete_count > length - start_index) {
            delete_count = length - start_index;
        }

        //  init - convert insertCount 
        let insert_count = insertCount;
        insert_count = (
            typeof insert_count === "symbol" ||
            typeof insert_count?.toString !== "function"
        ) ?
            0 :
            Math.trunc(Number(insert_count) || 0)
        ;
        if (insert_count < 0) {
            insert_count = 0;
        }

        const inserted_items = new Array(insert_count);
        for (let i = 0; i < insert_count; i++) {
            const inserted_item = new this.#template;
            inserted_items[i] = inserted_item;
        }
        if (items.length === 0 && inserted_items.length > 0) {
            for (const node of [...container.styles.children]) {
                node.remove();
            }
            container.styles.append(...inserted_items[0].styles.children);
        }

        const deleted_items = container.splice(start_index, delete_count, ...inserted_items);

        this.#onSpliced(this, start_index, delete_count, inserted_items);

        return deleted_items;
    }

    syncComponents(operation) {
        if (operation == null || operation.from === this || this.container == null) {
            return;
        }
        switch (operation.kind) {
            case ObservableArray.OperationKind.SORT: {
                this.#onSorted(operation.from, operation.indexMap);
                this.container.post(this.container.message("viewUpdated", "sort", { targetView: this }));
                break;
            }
            case ObservableArray.OperationKind.SPLICE: {
                this.#onSpliced(operation.from, operation.startIndex, operation.deleteCount, operation.insertedItems);
                this.container.post(this.container.message("viewUpdated", "splice", { targetView: this }));
                break;
            }
            default:
                break;
        }
    }

    onDataBinding(source) {
        if (source === null || typeof source !== "object") {
            throw new TypeError(`${source} is not a non-null object`);
        } else if (typeof source.syncComponents !== "function") {
            throw new TypeError(`${source} does not implement 'syncComponents' function`);
        }
    }

    /**
     * A constructor of the ViewLogic which is previously attached.
     * 
     * @type {(() => ViewLogic)?}
     * @see
     * - {@link ListView.prototype.attach}
     * - {@link ListView.prototype.detach}
     * 
     */
    #template = null;

    /**
     * Function invoked when items are sorted.
     * 
     * @param {ListView|ObservableArray} from 
     * manipulated object
     * 
     * @param {({from: number, to: number})[]} indexMap 
     * index map represented with an array of pairs of numbers.
     * Each of pairs has two properties "from" and "to",
     * the former is indicating the original index of an item and
     * the latter is indicating the destination index of that item.
     * 
     */
    #onSorted(from, indexMap) {
        if (from === this) {
            const binding_source = ObservableArray.sourceOf(this);
            if (binding_source == null) { return; }

            binding_source.syncComponents({
                from    : from,
                kind    : ObservableArray.OperationKind.SORT,
                indexMap: indexMap
            });
        } else {
            /**
             * @type {ListViewContainer?}
             */
            const container = this.container;
            if (container == null) { return; }
            /**
             * @type {ViewLogic[]?}
             */
            const items     = container.items;
            if (items == null) { return; }

            const sorted_items = [...items];
            for (const {from, to} of indexMap) {
                sorted_items[to] = items[from];
            }
            container.relateViewLogics({ items: sorted_items });

            container.container.append(...(function* () {
                for (const sorted_item of sorted_items) {
                    yield sorted_item.container;
                }
            })());
        }
    }

    /**
     * Function invoked when items are spliced.
     * 
     * @param {ListView|ObservableArray} from 
     * manipulated object
     * 
     * @param {number} startIndex 
     * An integer representing the position of the first item to be deleted or the previous sibling of inserted items.
     *
     * @param {number} deleteCount 
     * A number of items to be deleted.
     * 
     * @param {(ViewLogic[]|ObservableObject[])} insertedItems
     * An array of inserted items.
     */
    #onSpliced(from, startIndex, deleteCount, insertedItems) {
        if (from === this) {
            /** @type {ViewLogic[]} */
            const view_logics = insertedItems;
            const binding_source = ObservableArray.sourceOf(this);
            if (binding_source == null) { return; }

            binding_source.syncComponents({
                from         : from,
                kind         : ObservableArray.OperationKind.SPLICE,
                startIndex   : startIndex,
                deleteCount  : deleteCount,
                insertedItems: view_logics
            });
        } else {
            /**
             * @type {ListViewContainer?}
             */
            const container = this.container;
            if (container == null) { return; }

            /** @type {ObservableObject[]} */
            const oos            = insertedItems;
            const start_index    = startIndex;
            const delete_count   = deleteCount;
            const inserted_items = [];
            for (const oo of oos) {
                const inserted_item = new this.#template;
                oo.bindData(inserted_item);
                inserted_items.push(inserted_item);
            }
            if (this.length === 0 && inserted_items.length > 0) {
                for (const node of [...container.styles.children]) {
                    node.remove();
                }
                container.styles.append(...inserted_items[0].styles.children);
            }

            container.splice(start_index, delete_count, ...inserted_items);
        }
    }
}

export { ListView };
